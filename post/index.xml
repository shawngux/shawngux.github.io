<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Shawngu的网络日志</title>
    <link>https://shawngu.com/post/</link>
    <description>Recent content in Posts on Shawngu的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Aug 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://shawngu.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IPFS:点对点的超媒体协议</title>
      <link>https://shawngu.com/2018/08/ipfs%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9A%84%E8%B6%85%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/08/ipfs%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9A%84%E8%B6%85%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/</guid>
      <description>IPFS是什么？ IPFS(InterPlanetary File System):中文全称叫星际文件系统，名字听起来就酷炸了有木有，它是一种全新的点对点超媒体分发协议，基于内容和身份寻址的方式来存储和传输数据及文件，旨在让互联网更加快速、安全和开放。
IPFS是一种分布式文件系统，目的是将计算机设备通过相同的文件系统连接起来。
什么叫做超媒体？  超媒体就是指在互联网上传输的视音频、图片、文字等。我们目前广泛使用的http协议中文件的传输都是通过转成文本之间的传输，所以叫做超文本传输协议。
 什么叫做点对点？  说的简单点就是你我之间没有第三方。举个例子，我有一部小视频（咳咳，你懂得。。。），你想让我发给你爽一把，那么之前的话，我需要将小视频上传到第三方平台（百度云等），然后你从云盘下载，这个过程中百度云盘作为中间服务商存在，麻烦，还有可能存在其他问题。而现在，通过IPFS，你可以直接连接我的计算机文件系统，直接从我的这个文件系统中拿去爽就好，没有其他方参与，这就是点对点。如果是交易的话，便是没有中间商赚差价。
 什么是基于内容和身份寻址？  在我们现有的http协议中，是通过ip或域名来寻找资源，而在IPFS中，直接通过内容来寻找存储地。通俗来说，就是在IPFS中，每一文件的内容都有一个具体的标识符，我们叫hash值（即为身份或者标识），我们通过这个文件的内容hash值来获取这个文件。
 IPFS为什么存在？ 存在即合理。在提到IPFS为什么存在时，我们先说说http的不足。
在目前互联网协议中，http依旧占山为王。但随着互联网世界的高速发展，http的不足之处也凸显出来：
 数据易丢失  有的时候我们在访问网页时会出现404这样的页面，一般人都知道这是访问的页面不存在，或者访问到的页面上存在内容缺失的情况。这是典型的数据丢失，造成这种情况的原因有好多，可能是数据传输过程中被劫持丢失、网络不稳定、服务器宕机或直接挂掉等，每一环节都可能造成数据数据丢失。老子账号可是冲了会员的，会员呢？账号里的钱呢？卧了个大槽子，全没了，Game Over了。
 过度依赖主干网络  http高度依赖主干网，即简单说就是过度依赖那几根主要的光纤网络，谁也无法保证说主干网不会出问题。一旦出现问题，核心数据丢失，那没法愉快的玩耍了。
 数据高度中心化  现有互联网中的数据高度集中在几个牛逼服务器提供商手中，但也不可避免可能出现问题。前段时间，某大厂服务器bug造成一创业公司数据丢失，直接造成创业公司濒临倒闭，这得哭死。。。，另外数据高度集中，面临被集中攻击的可能性就大了。这可能造成一系列连锁问题。
 低效且服务器成本昂贵  http通过服务器来集中分发资源，传输效率低下，同时服务器本身带宽是很昂贵的。
以上是http暴露出的一列了相关的问题。出现问题就得解决问题，那么这时，IPFS闪亮登场了。
IPFS通过分布式存储（全网中的计算机全部参与存储）来解决数据高度集中的问题和原先过度依赖主干网络的问题，通过版本控制的方式（即可恢复的历史版本）来解决数据易丢失的问题，这样一来也就不存在服务器成本昂贵的问题了，方案看起来相当牛逼有木有，实际也很牛逼。这尼玛貌似是要完全替掉http的节奏（当然是否可以要待时间检验）。
IPFS有什么特点？ IPFS一些牛逼闪闪的特点：
1、本身是一个协议：  定义内容寻址文件系统 协调内容传递 整合Kademlia、BitTorrent、Git  2、也是一个文件系统：  拥有特定结构的目录和文件 本身是一个可安装的文件系统  3、本身也是一个网站  可通过web端查看文件（https://ipfs.io/） 散列寻址内容保证真实性  4、使用加密  通过加密hash内容类寻址 块级重复数据删除 文件完整性+版本控制 文件系统级加密+签名支持  5、同时也是一个CDN（内容分发网络）  在本地文件系统添加一个文件，可供全世界使用 缓存十分友好，都是通过内容hash命名 基于bittorrent的带宽分配  6、点对点（p2p）  全球对等文件传输 没有中心化的概念及中心化可能带来的问题 系统是完全分散的架构  其他……</description>
    </item>
    
    <item>
      <title>基于Truffle和Openzeppelin-solidity创建标准代币</title>
      <link>https://shawngu.com/2018/08/%E5%9F%BA%E4%BA%8Etruffle%E5%92%8Copenzeppelin-solidity%E5%88%9B%E5%BB%BA%E6%A0%87%E5%87%86%E4%BB%A3%E5%B8%81/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/08/%E5%9F%BA%E4%BA%8Etruffle%E5%92%8Copenzeppelin-solidity%E5%88%9B%E5%BB%BA%E6%A0%87%E5%87%86%E4%BB%A3%E5%B8%81/</guid>
      <description>在以太坊中创建代币需要符合ERC20协议标准，Openzeppelin是一个用来编写安全的以太坊智能合约的库，实现了RRC20协议，因此基于Openzeppelin和Truffle，我们可以很方便的创建我们自己的标准代币。
1、首先我们需要确保已经安装了npm 和 truffle
node-npm: https://nodejs.org/en/download/
$ npm install -g truffle  2、我们通过truffle unbox命令下载truffle官方给的tutorialtoken项目骨架，在此基础上开发自己的代币
首先我们新建一个目录，作为我们的项目目录
$ mkdir encrypted-token $ cd encrypted-token  然后下载tutorialtoken骨架
$ truffle unbox tutorialtoken Downloading... Unpacking... Setting up... Unbox successful. Sweet! Commands: Compile: truffle compile Migrate: truffle migrate Test contracts: truffle test Run dev server: npm run dev  4、然后安装openzeppelin-solidity库
$ npm install openzeppelin-solidity + openzeppelin-solidity@1.12.0 added 1 package in 13.191s  至此，项目结构搭建完成
encrypted-token contracts Migrations.sol migrations 1_initial_migraions.</description>
    </item>
    
    <item>
      <title>基于truffle、web3等框架的以太坊智能合约开发流程</title>
      <link>https://shawngu.com/2018/07/%E5%9F%BA%E4%BA%8Etruffleweb3%E7%AD%89%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/%E5%9F%BA%E4%BA%8Etruffleweb3%E7%AD%89%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid>
      <description>Truffle 官网：https://truffleframework.com
Truffle是针对于以太坊开发的一套框架，集成了以太坊智能合约的编译、部署环境和资产管理。旨在让基于以太坊开发变得更简单，更容易测试。同时truffle内部也整合的web3，方便调用以太坊底层接口。
1、安装
首先得安装npm，然后通过npm来全局安装。
$ npm install -g truffle  2、初始化项目
新建一个空的项目目录，然后通过命令进行初始目录
$ truffle init Downloading... Unpacking... Setting up... Unbox successful. Sweet! Commands: Compile: truffle compile Migrate: truffle migrate Test contracts: truffle test  初始化完成，生成对应项目结构
&amp;gt; demo &amp;gt; contracts // 合约文件目录 Migrations.sol &amp;gt; migrations // 编译文件目录 1_initial_migration.js &amp;gt; test // 测试文件目录 truffle-config.js truffle.js  3、创建合约
在contracts目录中创建自己的合约myContract.sol
pragma solidity ^0.4.24; contract MyContract { // 显示账户地址余额 function showBalance(address who) public constant returns (uint) { return who.</description>
    </item>
    
    <item>
      <title>Solidity函数类型</title>
      <link>https://shawngu.com/2018/07/solidity%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 26 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidity%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/</guid>
      <description>Solidity中，函数可以使用不同的关键字进行修饰，代表不同的类型函数，函数类型关键字常用的有view、constant、pure、payable。
View类型函数 将函数声明为view类型，代表该函数不会修改区块链中的状态。可看成只读类型的函数。调用只读状态类型的函数不会消耗gas。
pragma solidity ^0.4.24; contract Test { function func() public view returns (uint) { return 2 * 4 + now; } }  constant修饰函数时是view的别名，作用和view一样，代表只读状态。
pragma solidity ^0.4.24; contract Test { // constant &amp;lt;==&amp;gt; view function func() public constant returns (uint) { return 4 * 8 + now; } }  不修改状态相对的则是修改状态，以下情况被认为是修改状态。
 修改定义的状态变量 产生事件 创建其他合约 使用selfdestruct自毁函数 通过调用发送以太币 调用任何没有被标记为view或pure的函数 使用低级调用 包含特定操作码的内联汇编  注：在solidity中，编译器没有强制view函数一定不能修改状态，只是尽可以保证不修改以让其只读。
Pure函数 将函数声明为pure类型，这种情况下看成承诺不读取或修改状态。这个地方可理解为局部变量值返回。
pragma solidity ^0.4.24; contract Test { // 不会去读取和修改区块链中的状态。 function func() public pure returns (string) { return &#39;shawn.</description>
    </item>
    
    <item>
      <title>Solidity函数修饰器</title>
      <link>https://shawngu.com/2018/07/solidity%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidity%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E5%99%A8/</guid>
      <description>函数修饰器 在solidity中，当我们想要在执行某个函数之前处理一些行为，例如检查某个条件，这个时候函数修饰器可以轻松实现这样的要求。
pragma solidity ^0.4.24; contract Test { address owner; function Test() { owner = msg.sender; } // 定义修饰器，用于在执行函数前判断当前调用者是为合约拥有者 // _; 修饰器修饰的函数体会被插入到这个符号的位置。 modifier onlyOwner { require(msg.sender == owner); _; } // 使用修饰器修饰 function add() public constant onlyOwner returns (uint) { return 1 + 2; } }  修饰器也可以被继承，一个函数也可以被多个修饰器修饰，被多个修饰器修饰时，使用空格隔开。
pragma solidity ^0.4.24; contract Parent { address public owner; uint public value; modifier onlyOwner { require(msg.sender == owner); _; } modifier check { require(value &amp;gt; 10); _; } } contract Child is Parent{ function Child() { owner = msg.</description>
    </item>
    
    <item>
      <title>Solidty变量类型之结构体（Struct）、映射（Mapping）</title>
      <link>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93struct%E6%98%A0%E5%B0%84mapping/</link>
      <pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93struct%E6%98%A0%E5%B0%84mapping/</guid>
      <description>结构体 solidity中，结构体的定义很简单，通过struct关键字来声明。
pragma solidity ^0.4.24; contract Test { // 定义的新类型包含两个属性。 struct Animal { string name; string color; } Animal animal; function Test() { animal = Animal({name: &#39;dog&#39;, color: &#39;black&#39;}); } // output: dog, black function show() constant returns (string, string) { return (animal.name, animal.color); } }  注：solidity中可以通过元组的方式返回多个值，这个借鉴了Python的特性。元组通过()来表示。
映射 在solidity中，映射通过mapping(_keyType =&amp;gt; _valueType)的形式来声明。
https://solidity.readthedocs.io/en/latest/types.html#mappings
例如：mapping(address =&amp;gt; string)
pragma solidity ^0.4.24; contract Test { // 声明映射 mapping(address =&amp;gt; uint) public balances; function update(uint newBalance) public { balances[msg.</description>
    </item>
    
    <item>
      <title>Solidty变量类型之枚举（Enums）</title>
      <link>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9E%9A%E4%B8%BEenums/</link>
      <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9E%9A%E4%B8%BEenums/</guid>
      <description>枚举可以看成是有确定元素值的数据类型，例如，我们平常提到的方向，简单来说有东、南、西、北四个方向，那么我们可以定义一个Direction这个枚举类型。
pragma solidity ^0.4.24; contract Test { enum Direction {East, South, West, North} Direction direction; function setDirection() { direction = Direction.East; } // output: 0 可看成下标 function getDirection() constant returns (Direction) { return direction; } }  </description>
    </item>
    
    <item>
      <title>Solidty变量类型之数组（Arrays）</title>
      <link>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%95%B0%E7%BB%84arrays/</link>
      <pubDate>Sat, 21 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%95%B0%E7%BB%84arrays/</guid>
      <description>solidity中，数组分为固定长度数组，和可变长度数组。数组直接通过类型加[]来定义。
https://solidity.readthedocs.io/en/latest/types.html#arrays
例如：uint[3] arr = [1, 2, 3] 或者 uint[] arr = [1, 2, 3]
固定长度数组 固定长度数组是指在定义时就指定好长度的数组，指定长度后，长度不可再改变，索引下的值可以修改。
pragma solidity ^0.4.24; contract Test { uint[5] arr = [1, 2, 3, 4, 5]; // output: 5 function len() constant returns (uint) { return arr.length; } function setValue() { arr[0] = 10; } }  可变长度数组 可变长度数组即在声明的时候并没有指定长度大小，可以动态的改变。数组内的值可修改，亦可通过push来追加元素。
pragma solidity ^0.4.24; contract Test { string[] names = [&#39;shawn&#39;]; function pushValue() { names.push(&#39;tom&#39;); } function len() constant returns (uint) { return names.</description>
    </item>
    
    <item>
      <title>Solidty变量类型之字节数组（Byte Arrays）</title>
      <link>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84byte-arrays/</link>
      <pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84byte-arrays/</guid>
      <description>定长字节数组（Fixed-size byte arrays） https://solidity.readthedocs.io/en/latest/types.html#fixed-size-byte-arrays
定长字节数组是值类型变量。通过bytes1、bytes2、bytes3、&amp;hellip;&amp;hellip;、bytes32来定义。而byte是bytes1的别名。
例如：byte5 bt = 0x736861776e;
1、支持的运算符有：
 比较运算符：&amp;gt;=、&amp;gt;、&amp;lt;=、&amp;lt;、==、!=（返回布尔值）。 位运算符：&amp;amp;、|、^（异或）、~（取反）、&amp;lt;&amp;lt;（左移）、&amp;gt;&amp;gt;（右移）。 索引访问：如果 x 是 bytesI 类型，那么 x[k]（其中 0 &amp;lt;= k &amp;lt; I）返回第 k 个字节（只读）。  pragma solidity ^0.4.24; contract Test { // 0x736861776e =&amp;gt; shawn // 十六进制的两个字符或数字代表一个字节 bytes1 bt1 = 0x73; // 01110011 -&amp;gt; 一个字节 bytes2 bt2 = 0x7368; // 01110011 01101000 -&amp;gt; 两个字节 bytes3 bt3 = 0x736861; // 01110011 01101000 01100001 -&amp;gt; 三个字节 bytes4 bt4 = 0x73686177; // 01110011 01101000 01100001 01110111 -&amp;gt; 四个字节 bytes5 bt5 = 0x736861776e; // 01110011 01101000 01100001 01110111 01101110 -&amp;gt; 五个字节 // .</description>
    </item>
    
    <item>
      <title>Solidty变量类型之地址（address）</title>
      <link>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%9C%B0%E5%9D%80address/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%9C%B0%E5%9D%80address/</guid>
      <description>地址类型（Address） 在以太坊中，任何的交易都是通过地址来进行的，因此在智能合约中，地址类型是比较重要的一个变量类型。
以太坊区块链网络中，每一份智能合约有一个地址，每一个账户有一个独立的地址，地址的长度为20个字节，一个字节有8位。所以地址一共有160位。
地址的字面量表示为：0x14723a09acff6d2a60dcdf7aa4aff308fddc160c，0x代表十六进制，一个十六进制的数字等于4个字节，因此地址呈现出来的数字和字符是40个（除去0x）。
支持的运算符：
 &amp;gt;=、&amp;gt;、&amp;lt;=、&amp;lt;、==、!=。  pragma solidity ^0.4.24; contract Test { address addr1 = 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db; address addr2 = 0x583031d1113ad414f02576bd6afabfb302140225; // &amp;gt;= output: false function fnA() constant returns (bool) { return addr1 &amp;gt;= addr2; } // &amp;gt; output: false function fnB() constant returns (bool) { return addr1 &amp;gt; addr2; } // &amp;lt;= output: true function fnC() constant returns (bool) { return addr1 &amp;lt;= addr2; } // &amp;lt; output: true function fnD() constant returns (bool) { return addr1 &amp;lt; addr2; } // == output: false function fnE() constant returns (bool) { return addr1 == addr2; } // !</description>
    </item>
    
    <item>
      <title>Solidty变量类型之布尔类型（Boolean）、整型（Integer）</title>
      <link>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8Bboolean%E6%95%B4%E5%9E%8Binteger/</link>
      <pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8Bboolean%E6%95%B4%E5%9E%8Binteger/</guid>
      <description>布尔类型（Booleans） https://solidity.readthedocs.io/en/latest/types.html#booleans
bool：可能的取值为true和false。
支持的运算符有：
 !（逻辑非） &amp;amp;&amp;amp;（逻辑与，&amp;rdquo;and&amp;rdquo;） ||（逻辑或） ==（等于） !=（不等于）  注：运算符||和&amp;amp;&amp;amp;遵循短路规则。
pragma solidity ^0.4.24; contract Test { uint a; uint b; bool c; bool d; function Test() { a = 1; b = 2; c = true; d = false; } // output: false function fnA() constant returns (bool) { return !c; } // output: false function fnB() constant returns (bool) { return c &amp;amp;&amp;amp; d; } // output: true function fnC() constant returns (bool) { return c || d; } // output: false function fnD() constant returns (bool) { return a == b; } // output: true function fnE() constant returns (bool) { return a !</description>
    </item>
    
    <item>
      <title>Solidty变量类型</title>
      <link>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidty%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</guid>
      <description> Solidity是一种静态类型语言，需要和Java等静态语言一样，需要在编译时给每个变量指定具体的类型。Solidity提供了一些基本类型，通过基本类型，可以组合成一些复杂类型。
值类型 值类型的变量始终按值来传递，即当这些变量被用作函数参数或者赋值语句中，总是会进行值拷贝。当修改新的变量时，不会影响到原来变量的值。
 布尔类型（Booleans） 整型（Integers） 定长浮点型（Fixed Point Numbers） 地址类型（Address） 定长字节数组（Fixed-size byte arrays） 有理数和整型（Rational and Integer Literals） 字符串字面常量（String Literals） 枚举类型（Enums）  引用类型 引用类型在赋值的时候，既可以*值传递*，也可以*引用传递*（即地址传递），值传递时，仅是拷贝原变量的值，而引用传递时，修改新的引用变量，原来变量引用的值也会改变。
 字符串（String） 不定长字节数组（Dynamically-sized byte array） 数据位置（Data location） 数组（Arrays） 结构体（Structs）  </description>
    </item>
    
    <item>
      <title>Solidity访问修饰符（可见性）</title>
      <link>https://shawngu.com/2018/07/solidity%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</link>
      <pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidity%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</guid>
      <description>编辑器 例子中涉及到的代码，都是选用Remix这个编辑器来编译执行，并且都是执行通过的。以下简单介绍一下Remix编辑器的布局。
状态变量可见性 在solidity中，状态变量的访问修饰符有3种，分别是public、internal和private。默认是internal。
1、public：当访问修饰符为public时，该状态变量可以在合约内部、子合约和合约外部被调用。同时会自动生成一个同名的getter函数。
pragma solidity ^0.4.24; contract Test { string public name; function Test() public { name = &#39;shawn&#39;; } }  Output: fn &amp;ndash;&amp;gt; name
2、internal：当访问修饰符为internal时，该状态变量只能在内部访问，即可从当前合约内部或者有它派生的子合约中访问。与Java等其他语言的protected类似但不完全一样。
pragma solidity ^0.4.24; contract Parent { string internal name; } contract Child is Parent { function Child() public { name = &#39;shawn&#39;; } // output =&amp;gt; &amp;quot;shawn&amp;quot; function getName() returns (string) { return name; } }  3、private: 当访问修饰符为private时，该状态变量只能在当前定义它的合约中使用，也不可以被继承。
pragma solidity ^0.</description>
    </item>
    
    <item>
      <title>Solidity开发第一个智能合约</title>
      <link>https://shawngu.com/2018/07/solidity%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/solidity%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</guid>
      <description>Solidity概述 solidity是以太坊官方推出的编写智能合约的面向对象的高级编程语言，是一门图灵完备的程序设计语言，语法和风格类似JavaScript。通过solidity，我们可以根据自己的需求编写复杂的合约逻辑，其编写的智能合约运行在以太坊虚拟机（EVM），即Ethereum Virtual Machine中。
编辑器选择 编写代码，必不可少需要开发工具。以下简介三款开发工具：Remix、Atom、VS Code。
1、 Remix -&amp;gt; https://remix.ethereum.org
基于web浏览器的IDE，继承编译器和solidity运行时环境，无需服务器端组件。官方文档推荐说尝试solidity编程最好的方式，不习惯web编程的小伙伴应该不完全赞同这种说法，取决于各个喜好。界面如下：
2、Atom -&amp;gt; https://atom.io
github出品，专为程序员推出的跨平台轻量级编辑器，界面简介美观，插件丰富。界面如下：
3、VS Code -&amp;gt; https://code.visualstudio.com
微软开发的免费开源的编辑器，界面美观，性能出色，插件同样丰富。界面如下：
编写第一个智能合约 pragma solidity ^0.4.24; contract Person { string _name; uint _age; address _owner; // 合约拥有者 function Persion() { _owner = msg.sender; } /** * 修改名字 */ function setName(string name) public { _name = name; } /** * 返回名称 */ function name() public constant returns (string) { return _name; } function setAge(uint age) public { _age = age; } function age() public constant returns (uint) { return _age; } function destroy() { if (_owner !</description>
    </item>
    
    <item>
      <title>挖矿的基本原理及代码模拟实现nonce</title>
      <link>https://shawngu.com/2018/07/%E6%8C%96%E7%9F%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0nonce/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/%E6%8C%96%E7%9F%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0nonce/</guid>
      <description>基本原理 区块链网络中存储交易信息的区块源源不断的生成本质上是通过节点的挖矿来实现的，节点即所谓的矿工，而挖矿通俗点来说是指矿工抢夺记录交易信息（记账）权的过程。而隐藏在挖矿背后的是PoW共识（比特币）。
PoW(Proof of Work)，即工作量证明，所谓工作量证明，是指根据矿工贡献的算力多少来获得奖励，简单点说就是多劳多得。
挖矿的过程 节点根据上一个节点的hash值、当前时间戳、打包的交易信息去寻找一个nonce，从而让这几个数据整合生成的hash满足一定的难度，这个难度一般是指hash值前面0的个数。而nonce寻找过程是由1开始，依次累加，直到找到满足条件的hash为止，即生成了满足难度的区块。然后矿工将这个区块广播到区块链网络中，得其他节点检验，其他节点检验通过，便会将这个区块加到自己维护的链上。而生成区块的这个节点矿工便会在此后5个区块后，即第6个区块被确认后，获得奖励。
模拟生成nonce伪代码 /** * 检验hash值难度 * @param targetHash: 给定的hash值 * @param difficulty: 给定的难度 */ function isValidDifficulty(targetHash, difficulty) { var i; for (i = 0; len = targetHash.length, i &amp;lt; len; ++i) { if (&#39;0&#39; !== targetHash[i]) { break; } } return i &amp;gt;= difficulty; } /** * 生成nonce和目标hash值 */ function generate() { var nonce = 0; // 从0开始累加 var targetHash; // 目标hash var input; // hash运算的数据 var difficulty = 4; // 初始难度为4 while(isValidDifficulty(targetHash, difficulty)) { nonce = nonce + 1; input = index + prevHash + timestamp + data + nonce; targetHash = CryptoJS.</description>
    </item>
    
    <item>
      <title>区块链基础</title>
      <link>https://shawngu.com/2018/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/07/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/</guid>
      <description>一、区块链诞生的背景 在社会发展进程中，金融科技是保障社会文明的重要支柱，而记账这一行为或称为记账科技则是金融科技最核心的支柱基石。
以往，无论是传统的交易，还是互联网上的经济金融贸易，几乎都需要借助可被广泛大众认可和信赖的第三方信用结构（银行、支付宝等）中的账本来记录，这样的话交易信息掌握在个体手中，同时涉及到多个交易方的情况下，需要分别维护各自的账本，可能出现不一致抑或对账困难的情况，而且，一旦出现数据遗失，则有可能无法找回。
随着交易信息受限于“基于信用”这一模式的一系列可能出现的问题，去中心化，分布式账本这一概念出现。于是，区块链技术随之而来。
二、区块链的发展历程 区块链发展至今，经历了三次浪潮：
 第一个浪潮出现在2013左右，此前，一个名为中本聪的在一封加密邮件中发布比特币白皮书《比特币：一种点对点的电子现金系统》，并在09年公开最初的实现代码，由此比特币项目上线，但在很长一段时间内并未引起太多的关注，直到比特币的价值暴涨，各种加密货币在此时期纷纷出现，因此，隐藏在其背后的区块链技术才首次引起大家的关注。这一时期，我们称之为区块链1.0时代。 第二个浪潮出现在2016年前后，这一时期，区块链技术也有了自身的突破，首个大规模的公有智能合约引擎&amp;ndash;以太坊（Ethereum）项目正式上线（我们称之为区块链2.0）。于此时期内，首个面向企业应用的联盟式分布式账本&amp;ndash;超级账本（HyperLedger Fabric）,在一些企业巨头支持下成立（我们称之为区块链2.5）。 第三个浪潮，从2017年开始至今，众多互联网领域的资本开始关注区块链，人才缺口也相应的持续加大，区块链成为继人工智能后的又一个资本追逐以及技术的热点。由此及未来的一段时间，我们称之为区块链3.0时代。  三、区块链中一些概念  定义  狭义上：区块链就是一种以区块为基本单位的链式存储结构。 广义上：区块链是指基于区块链存储结构实现的分布式账本。    基本原理  矿工：即参与维护区块链网络的每一个节点 挖矿：矿工通过不断计算得出一个满足给定难度的随机数从而生成符合记录交易数据的区块并获得奖励的过程，即矿工争夺记账权的过程。 交易：一次对账本的操作，如添加一条转账记录。 hash：一种摘要算法，将给定的输入经过hash运算，得到一个固定长度的无规律字符串，给定的输入即使有非常细微的不同，hash过后的字符串也会有非常大的差别。 nonce：随机串，即节点通过将上一个区块打包的内容加上不断计算得出的这个nonce进行hash，从而可以得出一个满足指定难度的一个hash值。 PoW(Proof of Work)：即工作量证明，在区块链网络中指的是节点贡献的算力，也就是共识（此种共识存在一定的不足，因此PoW和PoS之争的话题常有）。   以比特币为例阐述基本原理：
首先，比特币客户端（比特币钱包等）发起一个转账交易，这笔交易广播到比特币网络中等待确认，网络中的节点接收到广播，便将待确认的交易记录打包在一起，组成一个候选区块，然后通过不断的暴力计算，试图找到一个随机串nonce，放到这个候选区块里，从而让这个候选区块的hash值满足一定的条件（例如小于某个特定的值）。一旦某个节点找到了这个nonce值，这个区块就可被认为是合法的，节点就会尝试将这个区块广播到区块链网络中。其他节点接收到这个区块后，进行验证，验证通过，则会将这个区块添加到自己维护的区块链上。当大部分节点都将这个区块添加到自己维护的区块链上后，这个区块则被全网接受，区块中的交易得到确认。而生成该区块的节点（即矿工）会接收到比特币奖励，但比特币不是立刻到达矿工的钱包，而是会在该区块之后的5个新区块被确认后，即第6个区块确认时收到。
四、比特币(BTC)的一些特点 比特币本质上就是一种加密货币，基于区块链技术的一种数字货币实现，也是历史上首个经过大规模长时间检验的数字货币系统。
 去中心化：没有第三方的机构或者中介可以对网络中的交易进行破坏，任何交易都是基于共识来进行。 隐私匿名性：网络中交易的地址是匿名的，通过一个34位的地址来进行交易，避免了直接关联到具体的个体。 安全性：网络中交易存储是分布式的，每一个节点都维护一个完整的区块链，即使其中有个别节点异常也不会影响网络的运转。除非掌握全网51%及其以上算力，即可控制整个区块链。 总量一定：比特币总量固定，只有2100万枚。 每产生210000个区块后，比特币产量减半。 系统给矿工的奖励每4年减半，最开始是50个。 比特币区块的大小不超过1M，最多不超过4000笔交易，每个交易250字节。 共识机制：工作量证明（PoW)、只在最长链上添加，即只认可最长链。 比特币网络不是图灵完备的。  交易输入和输出
比特币交易中有一个重要的概念叫UTXO(Unspent Transaction Outputs)，即未被引用的交易输出，也可以将其看作是比特币交易中的单位，通俗点将类似人民币中的10、20、100这样的面额。
 交易输出：不同面额的UTXO由交易输出提供。一个交易输出中包含两个部分，一是定量的比特币，单位为“聪”，二是包含一个锁定脚本。 交易输入：前一个有效的交易输出可以被新的交易引用作为其输入，这也就称之为交易输入。 比特币中最小单位即为“聪”，1“聪”等于10^-8比特币，即一亿分之一比特币。  交易脚本
为了保障交易的完成，比特币交易中引入交易脚本（Script），交易脚本主要用来检验交易的合法性。每个交易一般会包含两个脚本，负责输入的解锁脚本（scriptSig）和负责输出的锁定脚本（scriptPubKey）。
 解锁脚本：也可称之为输入脚本，是接收方用来证明自己是发送方发送的对象，即自己满足解锁认领对方输出的比特币。 锁定脚本：也可称为输出脚本，是由付款方对当前发送的交易进行锁定，规定谁能动这笔交易的输出，例如限定了只有拥有某个公钥的另一方才有对这笔交易的花费权。  五、以太坊（Ethereum）的一些特点 随着区块链技术的进一步发展，以太坊项目对以比特币为主的数字货币交易系统的功能进一步扩展，支持智能合约这一特性，从而让基于区块链的数字货币系统有了更灵活的应用场景。
 支持图灵完备的智能合约，可以运行更复杂的自定义合约规则。 平台独立设计了solidity语言，并运行于EVM（Ethereum Virtual Machine），即以太坊虚拟机。 支持PoW共识算法，同时支持效率更高的PoS共识算法 抛弃UTXO,采用账户系统和世界状态。 叔块（Uncle Block）激励机制，降低集中式矿池的优势。所谓叔块激励，是指一个矿工生成了满足条件的区块后，另一个矿工随后或同时也生成了满足条件的另一个区块，这两个区块属于不同分支的同辈，对于一个分支上的下一个区块而言，另一个分支上的区块则是称为它的叔块，生成叔块的节点同样会获得奖励。 采用gas来限制执行合约数，避免循环执行攻击。即每执行一次合约，都会消耗一定的gas，gas可与以太币进行兑换。  核心概念</description>
    </item>
    
    <item>
      <title>Python网络编程</title>
      <link>https://shawngu.com/2018/03/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sat, 31 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>Python是一个很强大的网络编程语言，对网络协议的各个层次进行了封装。这样我们不必再去关系网络实现的细节，可以集中精力处理程序逻辑部分。
Socket Socket（套接字）可以看成是两个端点程序之间的信息通道。程序分布在不同的计算机或者网络上，通过套接字相互发送信息。在Python中，通过Socket模块来创建这样的连接。
套接字包括两个：服务器套接字和客户端套接字。在创建一个服务器套接字后，让它等待连接，这样它就会在某个网络地址处（IP地址和端口的组合）监听，直到有客户端的套接字连接，连接成功后，就可以进行交互了。
在Python的Socket模块中，一个套接字就是socket类的一个实例。实例化需要给定3个参数：第一个参数是地址族（默认是socket.AF_INET）;第2个参数是流（默认是socket.SOCK_STREAM）或数据报（socket.SOCK_DGRAM）,第3个参数是使用的协议（默认是0，一般使用默认值即可）。
服务器套接字使用bind方法后，再调用listen方法去监听某个特定的地址。
客户端套接字使用connect方法连接到服务器，在connect方法中使用的地址与服务器在bind方法中的地址相同。
服务器套接字开始监听后，它就可以接受客户端的连接。通过accetp来完成。这个方法会阻塞（等待）直到客户端连接，然后返回一个格式为(client, address)的元组，client是一个客户端套接字。服务器处理完与该客户端的连接后，再次调用accept方法开始等待下一个连接。
套接字有两个方法send（发送）和recv（接收），来传输数据。
TCP编程 TCP是面向于有连接的协议，建立可靠的协议，双方通信确认以后可传输数据。具体看代码：
服务器 import socket # 创建socket对象 s = socket.socket() host = &#39;127.0.0.1&#39; port = 8888 # 监听地址和端口 s.bind((host, port)) # 指定等待连接的最大数量 s.listen(5) # 无限循环接口客户端的连接 while True: sock, addr = s.accept() print(&#39;connected from %s:%s :&#39; % addr) sock.send(b&#39;thank you for connecting&#39;) sock.close()  上面的程序是一个小型服务器，连接客户端的连接，连接成功后会给客户端发送一句话“thank you for connecting”
客户端 创建一个客户端来连接服务器
import socket # 创建socket对象 s = socket.socket() host = &#39;127.0.0.1&#39; port = 8888 # 连接服务器 s.</description>
    </item>
    
    <item>
      <title>Python访问数据库</title>
      <link>https://shawngu.com/2018/03/python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>使用文件等相关方式存储数据总归是很有限的，当我们需要存储大量数据的时候，数据库这个时候就相当有用了。
SQLite SQLite是一种嵌入式数据库，体积很小，常常被嵌入到应用中。而Python就内置了SQLite，可以直接导入使用。
import sqlite3 # 创建连接，如果不存在该库就在当前目录下创建 conn = sqlite3.connect(&#39;test.db&#39;) # 创建游标 curs = conn.cursor() # 建表 query = &#39;create table user (id int primary key, name varchar(15))&#39; curs.execute(query) # &amp;lt;sqlite3.Cursor object at 0x108fe9c70&amp;gt; # 插入数据 query = &#39;insert into user values (1, &amp;quot;shawngu&amp;quot;), (2, &amp;quot;jack&amp;quot;), (3, &amp;quot;rose&amp;quot;)&#39; curs.execute(query) # 提交事务 conn.commit() cursor.close() # 查询 curs = conn.cursor() query = &#39;select * from user&#39; curs.execute(query) # &amp;lt;sqlite3.Cursor object at 0x108fe9c70&amp;gt; # 获取查询结果集 rows = curs.</description>
    </item>
    
    <item>
      <title>Python图形界面库</title>
      <link>https://shawngu.com/2018/03/python%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BA%93/</link>
      <pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BA%93/</guid>
      <description>Python支持多种第三方的图形界面库。常见有：
 Pyqt：anaconda中自带
 wxPython
  推荐使用anaconda集成包作为Python环境，在anaconda中安装wxpython很简单：
conda install -c melund wxpython   Tkinter：这个包Python中自带  使用哪个库导入即可
# 使用pyqt import pyqt # 使用tkinter import tkinter # from tkinter # 使用wxpython import wx # wxpython  </description>
    </item>
    
    <item>
      <title>Python文件和流相关操作</title>
      <link>https://shawngu.com/2018/03/python%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>文件的操作是典型的I/O操作，而文件操作中读和写又是最常用的。
读文件 open函数用来打开一个文件，并返回一个文件对象。模式打开模式即为读。
格式：open(name, [mode, [buffering&amp;hellip;]])
其中：name为文件名，强制参数，其他为可选参数。
# 等价于 open(&#39;/Users/shawn/Desktop/f.txt&#39;, &#39;r&#39;) f = open(&#39;/Users/shawn/Desktop/f.txt&#39;) print(f) # _io.TextIOWrapper name=&#39;/Users/shawn/Desktop/f.txt&#39; mode=&#39;r&#39; encoding=&#39;UTF-8&#39;&amp;gt;  如果文件不存在，就会报错
f = open(&#39;/Users/shawn/Desktop/ff.txt&#39;) &#39;&#39;&#39; Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; FileNotFoundError: [Errno 2] No such file or directory: &#39;/Users/shawn/Desktop/ff.txt&#39; &#39;&#39;&#39;  文件打开后，可以使用read函数一次性读取全部内容，也可以指定读取的字符数。
# 读取全部 f.read() # 返回 &#39;Hello, World!!!&#39; # 读取指定字符数 f.read(5) # 返回 &#39;Hello&#39; # 在此调用读写，就是读取剩下的内容了 f.read() # 返回 &#39;, World!!!&#39;  也可以使用readline和readlines来读取行。</description>
    </item>
    
    <item>
      <title>Python模块</title>
      <link>https://shawngu.com/2018/03/python%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E6%A8%A1%E5%9D%97/</guid>
      <description>自定义模块 一般的，当我们想让代码重用的时候，就可以将代码放到一个模块中，这样一来，就可以再多个程序中使用这些代码了。其中一个xxx.py文件就是一个模块
例如，我们编写一个简单的模块保存到hello.py文件中：
def hello(): print(&#39;hello world&#39;) if __name__ == &#39;__main__&#39;: hello()  这样，当我们在命令行通过python hello.py时，就会输出&amp;rsquo;hello world&amp;rsquo;。
解释：
name变量用来“告知”模块本身是作为程序运行还是导入到其他程序。当我们在“主程序”（包括命令行）执行这个模块时，Python解释器就会将name的值设置为main，而在导入的模块中，这个值就被设定为模块的名字。所以，为了让模块更加好用，一般将其放置在if语句中。
内置模块 Python自身内置了很多的模块，可以直接拿来用，要使用模块，通过import语句导入就可以使用了。如使用内置的sys和pprint模块：
import sys import pprint # 打印系统模块列表 pprint.pprint(sys.path)  注：当要打印的数据结构过大，不能在一行打印完，就可以使用pprint模块中的pprint函数替代普通的print语句。pprint函数能够提供很假只能的打印输出。
探究模块 想要合理有效的使用模块，就必须对模块有所熟悉，知道模块里到底有什么，以及一些其他的细节。所谓“知己知彼”，才能运用自如。
想要知道模块细节，最直接的方式就是在Python解释器中研究它们。研究的第一步是知道模块的名字，然后导入它，如sys：
import sys  使用dir 查看模块中包含的内容可以使用dir函数，它会将模块的的所有函数、类和变量等列出。
dir(sys)  使用help获取帮助 help函数可以帮助我们模块的一些更加详细的说明，如：
help(sys) # 展示信息 &#39;&#39;&#39; Help on built-in module sys: NAME sys MODULE REFERENCE https://docs.python.org/3.6/library/sys The following documentation is automatically generated from the Python source files. It may be incomplete, incorrect or include features that are considered implementation detail and may vary between Python Help on built-in module sys: 。。。。。。 &#39;&#39;&#39;  使用文档 当我们想要查看模块的一些描述时，可以使用doc查看，如：</description>
    </item>
    
    <item>
      <title>Python高级特性之列表生成式、生成器和迭代器</title>
      <link>https://shawngu.com/2018/03/python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>列表生成式 Python中提供了一种非常简洁的方式来生成列表list。
例如：要生成[1x1, 2x2, 3x3, 4x4, 5x5, 6x6, 7x7, 8x8, 9x9]这样的一个列表。
一种方式是使用循环，如：
squares = [] for x in range(10): squares.append(x * x) print(squares) # 返回[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]  另一种方式是使用一个map和匿名函数lambda，如：
squares = list(map(lambda x: x*x, range(10))) print(squares) # 返回[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]  而最简洁的方式则肯定是使用列表生成式了，看代码：
squares = [x * x for x in range(10)]  说明：在一个列表中，使用for循环生成需要的值，for前面即是最终存放在列表中的具体值。在列表生成式中，甚至可以嵌套for循环，并且可以加判断，看代码：
number_tuples = [(a, b) for a in [1, 2, 3, 4] for b in [&#39;a&#39;, &#39;b&#39;]] print(number_tuples) # 返回[(1, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;a&#39;), (3, &#39;b&#39;), (4, &#39;a&#39;), (4, &#39;b&#39;)] # 加判断 number_tuples = [(x, y) for x in [1,2,3] for y in [3,1,4] if x !</description>
    </item>
    
    <item>
      <title>Python异常处理</title>
      <link>https://shawngu.com/2018/03/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>在编写程序的时候，难免会遇到程序可能出现异常的情况，这个时候如果我们不做捕获处理，异常就会一直往上抛，即回溯（traceback）终止程序往下执行，如：
print(1/0) # 返回 Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; ZeroDivisionError: division by zero  处理异常 异常可能在某些东西出错时自动引发，当异常触发后我们应当针对于其作出处理方式。
抛出异常 当我们指定某个程序可能出现的异常时，可以通过raise抛出指定的异常，如：
def test(n): if n == 0: raise ValueError(&#39;invalid value: %s&#39; % n) else: return 1 / n # 调用 test(0) # 返回信息 Traceback (most recent call last): File &amp;quot;test.py&amp;quot;, line 8, in &amp;lt;module&amp;gt; test(0) File &amp;quot;test.py&amp;quot;, line 3, in test raise ValueError(&#39;invalid value: %s&#39; % n) ValueError: invalid value: 0  其中，ValueError是Python内建的异常类对象，是Exception异常类的子类，所有异常类都继承与Exception。更多内建异常类参考：https://docs.</description>
    </item>
    
    <item>
      <title>Python面向对象编程</title>
      <link>https://shawngu.com/2018/03/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 21 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</guid>
      <description>Python本身是一种面向对象编程语言，面向对象编程（Object Oriented Programming），简称OOP，是一种编程思想，OOP将对象作为编程的基本单元，一个对象包含了数据以及对数据操作的函数。面向对象编程都有下面几个特点：
 封装 继承 多态  在说面向对象编程特点前，先说说类（class）和对象（object）的概念。
类和对象 类（class）：一种抽象的模板，它定义了一组对象的共有特点。例如人类。
对象（object）：是类的实例（instance）。例如男人、女人等。
类的定义 类通过关键字class来定义，后面紧跟着类名，如：
class Person: pass  如果需要继承某个类，需要在类名后加（class_name），如：
class Person(object): # 表示Person类继承object类 pass  创建对象 类定义好后，便可以创建一个实例，也叫创建对象，创建对象很简单，如：
man = Person() print(man) # 返回&amp;lt;__main__.Person object at 0x1083ed390&amp;gt;，0x1083ed390表示对象在内存中的地址  对象创建好后，可以动态的给对象绑定属性：
man.name = &#39;shawn.gu&#39; print(man.name) # 返回 shawn.gu  另外我们可以在类定义的时候初始化一些属性，这样在创建对象后，这些属性就会自动绑定到对象上。
# 通过__init__ （两边都是两个下划线）函数 class Person(object): def __init__(self, name, age): self.name = name self.age = age  这样在实例化时可以传入参数进行绑定具体值：
man = Person(&#39;shawn.gu&#39;, 25) print(man.name) # 返回shawn.</description>
    </item>
    
    <item>
      <title>Python函数式编程</title>
      <link>https://shawngu.com/2018/03/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程又叫面向过程编程，Python对函数式编程提供部分支持，但是Python并不是一个完全的函数式编程。
高阶函数 简单的说就是一个函数将另一个函数作为参数传入函数中，这样的函数就是高阶函数。如：
def f(a): return a**2; def oper(x, f): # f函数作为参数传入 return f(x)  一些内建高阶函数：
map map()函数接收两个参数，第一个参数是一个函数，第二个参数为可迭代的对象Iterable,例如序列。map将函数作用于可迭代的对象的每一个元素，并返回一个Iterator。看代码：
def f(x): return x**2 numbers = [1, 2, 3, 4, 5] res = map(f, numbers) print(list(res)) # 返回[1, 4, 9, 16, 25]  reduce reduce是functools模块中的一个函数，它把一个函数作用在给定的序列上，而这个参数函数必须接收两个参数，每次执行都会把结果继续和序列的下一个元素做累积计算，直接看代码：
from functools import reduce def fn(a, b): return a * 10 + b numbers = [1, 2, 3, 4, 5] res = reduce(fn, numbers) # 将给定的序列转成12345 print(res) # 返回12345  filter filter函数用来过滤一个序列，filter接收两个参数，第一个参数是一个函数，第二个参数是一个序列，它将函数作用于序列的每一个元素，然后根据结果为True还是False决定是否过滤舍弃掉这个元素。结果返回一个可迭代对象。看代码：</description>
    </item>
    
    <item>
      <title>Python递归函数</title>
      <link>https://shawngu.com/2018/03/python%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</guid>
      <description>递归函数说的简单一点就是在函数内部自己调用自己。那么这个函数就是递归函数。如：
def recursion(): return recursion()  上面这个就是一个简单的递归函数。当然这样的函数什么事情也做不了，并且是个无穷递归，一旦执行就永不结束，很快程序就会崩溃。所以这样的递归函数时没有意义的。
一个有用的递归应当包含几个部分：
 必须有结束条件，即一般说的有返回值 包含一个或多个问题较小部分的递归调用，简单的说就是每一次递归调用都更接近于最小可能性的解  下面两个经典递归应用
阶乘 n的阶乘定义为 n x (n-1) x (n-2) x (n-3) x &amp;hellip; x 1。
简单分析：
 1的阶乘为1 大于1的数的阶乘为n x (n-1) 的阶乘  代码实现：
def factorial(n): if n == 1: return 1 else: return n * factorial(n-1)  二分法查找 即每次折半查找，如要查找一个数是否在序列内，以中间序列中中间数字为基准进行判断，如果比中间数字大，将序列折半，然后再取右侧折半后的序列的中间数再进行比较查找，依次这样下去，找到返回。如果数比原序列中间数小，则左边做同样的查找。
代码实现：
def binary_search(seq, target_number, lower=0, upper=None): if upper is None: upper = len(seq)-1 if lower == upper: assert target_number == seq[upper] return upper else: middle = (lower + upper) // 2 # 先除以2再向下取整 if target_number &amp;gt; seq[middle]: return binary_search(seq, target_number, middle+1, upper) else: return binary_search(seq, target_number, lower, middle)  总结 所有的递归一般都可以写成循环的形式，递归优点是逻辑要比循环清晰，但是递归存在栈溢出的问题。所有是否要使用递归，酌情选择。</description>
    </item>
    
    <item>
      <title>Python函数和参数</title>
      <link>https://shawngu.com/2018/03/python%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 17 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0/</guid>
      <description>当我们在多个地方要使用同一个功能时，如果处都编写一次一样的代码，那么这样下来，整个程序会变得冗余不堪。为了解决这个问题，我们需要将一样功能的代码进行抽象封装，然后在需要的时间调用就行了，函数便是抽象的一个具体方式。
函数分为内建函数和自定义函数，内建函数直接拿过来调用就好了，如：
max(5, 15) # 求两数最大值  其他更多内建函数参考：https://docs.python.org/3/library/functions.html
这里主要探讨自定义函数
创建函数 在Python中，定义函数使用关键字def，紧接着是函数名、()和冒号:。函数体要缩进（四个空格）。看代码：
# 无返回值 def my_func(): print(&#39;hello,world&#39;) # 有返回值 def my_func2(): a = 5 return a # 返回多个值 def my_func3(): a, b = 1, 2 return a, b # 空函数，pass表示什么也不做，占个位而已。 def my_func4(): pass  注：通过return也可以返回None，直接return None即可。另外当一个函数什么也不做时，要给一个pass，否则程序会报错
函数调用 函数调用直接通过函数名加参数（有参数的话）即可，如：
my_func() abs(-10)  函数的参数 Python中函数的参数分为多种：
 位置参数：对于一般的函数，比如abs(x)、max(a, b, c)等，括号里x、a、b、c都是位置参数，调用函数时，按照位置顺序赋给参数指定的值。  # 定义函数 def compare(x, y): if x &amp;gt; y: print(&#39;x大于y&#39;) else: print(&#39;x小于等于y&#39;) # 调用函数 a, b = 5, 20 compare(a, b) # 打印 x小于等于y   默认值参数：在定义参数的时候给定默认值，这样一来，在调用函数时，即使不再给定义的参数传值函数也能正确的调用。有了默认参数，函数的使用就更加方便了一些。  def student(name, age, sex=&#39;male&#39;): print(&#39;name=&#39;, &#39;,age=&#39;, age, &#39;,sex=&#39;, sex) # 调用函数，这里并没有传入第三个参数，但因为在定义时给了默认值，所以在函数内部可以正常使用，并且函数调用正常 student(&#39;tom&#39;, 25) # 打印 name= ,age= 25 ,sex= male  注：默认参数必须在位置参数（必选参数）后面。</description>
    </item>
    
    <item>
      <title>Python中的赋值魔法</title>
      <link>https://shawngu.com/2018/03/python%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E9%AD%94%E6%B3%95/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E9%AD%94%E6%B3%95/</guid>
      <description>在Python，用好一些赋值的小技巧可以让我们程序很简洁高效。
序列解包 也叫递归解包，即将多个值的序列解开，然后放到变量的序列中。可以一次进行多个赋值操作。
x, y, z = 1, 2, 3 print(x, y, z) # 返回1 2 3 x, y = y, x # 两个变量值互相交换，很有用哦 print(x, y, z) # 返回2 1 3 names = &#39;shawn&#39;, &#39;tom&#39;, &#39;jack&#39; print(names) # 返回(&#39;shawn&#39;, &#39;tom&#39;, &#39;jack&#39;) 元组 a, b, c = names print(a + &#39;,&#39; + b + &#39;,&#39; + c) # 返回 shawn,tom,jack student = {&#39;name&#39;: &#39;kate&#39;, &#39;age&#39;: 25} k, v = student.popitem() print(&#39;key=&#39;,k, &#39;value=&#39;, v) # 返回 key= age value= 25  小结：使用序列解包赋值的时候，变量的个数要和赋的值个数相同。</description>
    </item>
    
    <item>
      <title>Python中的一些迭代工具</title>
      <link>https://shawngu.com/2018/03/python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%AD%E4%BB%A3%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 14 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%AD%E4%BB%A3%E5%B7%A5%E5%85%B7/</guid>
      <description>在Python中迭代序列或者其他可迭代对象时，有一些函数非常好用。
并行迭代 即程序可以同时迭代两个序列，如：
students = [&#39;jack&#39;, &#39;kate&#39;, &#39;tom&#39;, &#39;mate&#39;] ages = [21, 18, 23, 27] # 名字对应年龄 # range为列表生成式，在这里生成从0到len(students)的整数列表 for i in range(len(students)): print(students[i], &#39;=&#39;, ages[i]) # 打印 jack = 21 kate = 18 tom = 23 mate = 27  使用内建函数zip将两个序列压缩在一起，返回一个元组为成员的列表，然后进行并行迭代。
students = [&#39;jack&#39;, &#39;kate&#39;, &#39;tom&#39;, &#39;mate&#39;] ages = [21, 18, 23, 27] # zip(students, ages) 在迭代时会返回[(&#39;jack&#39;, 21), (&#39;kate&#39;, 18), (&#39;tom&#39;, 23), (&#39;mate&#39;, 27)] for stu, age in zip(students, ages): print(&#39;stu=&#39;,stu, &#39;,age=&#39;, age) &#39;&#39;&#39;返回 stu= jack ,age= 21 stu= kate ,age= 18 stu= tom ,age= 23 stu= mate ,age= 27 &#39;&#39;&#39;  按索引迭代 有时候想要迭代当前序列中的对象，同时还要获取当前对象的索引，看下面代码：</description>
    </item>
    
    <item>
      <title>Python流程控制之条件判断、循环</title>
      <link>https://shawngu.com/2018/03/python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Tue, 13 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF/</guid>
      <description>条件判断 计算机能执行一些复杂的、自动化的任务，关键在于自己能够根据条件作出判断。
条件判断语句为：if&amp;hellip;elif&amp;hellip;else。
完整形式为：
if &amp;lt;condition1&amp;gt;: &amp;lt;operation1&amp;gt; elif &amp;lt;condition2&amp;gt;: &amp;lt;operation2&amp;gt; else: &amp;lt;operation3&amp;gt;  其中elif可有多个。当if后面的条件为真（True）时，就会执行if后的操作，而elif和else就会被忽略掉。如果if后面条件为假（False），就会向下去执行elif，如果所有elif的条件也都为假，最后会执行else的操作。
看代码：
# if...else name = &#39;jack&#39; if name == &#39;shawn&#39;: print(&#39;找到shawn了&#39;) else: print(&#39;不是shawn&#39;） # 执行该语句，返回&#39;不是shawn&#39; # if...elif...else age = 18 if age &amp;lt;= 13: print(&#39;少年你好&#39;) elif age &amp;lt;= 20: print(&#39;哟，青年才俊嘛&#39;) # 执行该语句 else: print(&#39;再过几年就是油腻的大叔啦&#39;)  一些常用的条件：
   表达式 描述     x == y x 等于 y   x &amp;lt; y x 小于 y   x &amp;lt;= y x 小于等于 y   x &amp;gt; y x 大于 y   x &amp;gt;= y x 大于等于 y   x !</description>
    </item>
    
    <item>
      <title>Python高级类型之字典(dict)和集合(set)</title>
      <link>https://shawngu.com/2018/03/python%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E5%85%B8dict%E5%92%8C%E9%9B%86%E5%90%88set/</link>
      <pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E5%85%B8dict%E5%92%8C%E9%9B%86%E5%90%88set/</guid>
      <description>Dict 字典是Python中唯一内建的映射类型，在Python中用dict表示。字典中的项没有特定的顺序，使用键值对（k-v）来存储元素，其中键（k）唯一，但值（v）可以不唯一。
创建和使用字典 字典的创建可以直接通过{}；也可以使用dict函数，给参数来创建，参数可以是其他字典或者(k, v)形式的元组。具体看代码：
# 直接通过{}创建，键值间用冒号隔开，项间用逗号隔开 students = {&#39;jack&#39;: 20, &#39;tom&#39;: 23, &#39;shawn&#39;: 18} # 通过dict函数，加参数形式， items = [(&#39;name&#39;, &#39;shawn&#39;), (&#39;age&#39;, 18)] d = dict(items) # 返回{&#39;name&#39;: &#39;shawn&#39;, &#39;age&#39;: 18} animal = dict(name=&#39;dog&#39;, color=&#39;grey&#39;) # 返回{&#39;name&#39;: &#39;dog&#39;, &#39;color&#39;: &#39;grey&#39;}  字典是一种映射类型，但一些操作和通过序列很相似：
 len()返回字典中项的数量  d = {&#39;name&#39;: &#39;shawn&#39;, &#39;sex&#39;: &#39;male&#39;, &#39;age&#39;: 18} len(d) # 返回3   d[k] 返回键对应的值  d = {&#39;name&#39;: &#39;shawn&#39;, &#39;sex&#39;: &#39;male&#39;, &#39;age&#39;: 18} d[&#39;name&#39;] # 返回&#39;shawn&#39;   d[k] = v 赋值  d = {&#39;name&#39;: &#39;shawn&#39;, &#39;sex&#39;: &#39;male&#39;, &#39;age&#39;: 18} d[&#39;name&#39;] = &#39;jack&#39; print(d) # 返回{&#39;name&#39;: &#39;jack&#39;, &#39;sex&#39;: &#39;male&#39;, &#39;age&#39;: 18}   del d[k]删除键为k的项  d = {&#39;name&#39;: &#39;shawn&#39;, &#39;sex&#39;: &#39;male&#39;, &#39;age&#39;: 18} del d[&#39;name&#39;] print(d) # 返回{&#39;sex&#39;: &#39;male&#39;, &#39;age&#39;: 18}   k in d 检查是否存在键为k的项  d = {&#39;name&#39;: &#39;shawn&#39;, &#39;sex&#39;: &#39;male&#39;, &#39;age&#39;: 18} &#39;name&#39; in d # 返回True  字典的格式化字符串 使用字典来格式化字符串有时非常便捷高效，直接看代码：</description>
    </item>
    
    <item>
      <title>Python序列类型之列表(list)和元组(tuple)</title>
      <link>https://shawngu.com/2018/03/python%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8list%E5%92%8C%E5%85%83%E7%BB%84tuple/</link>
      <pubDate>Sat, 10 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8list%E5%92%8C%E5%85%83%E7%BB%84tuple/</guid>
      <description>列表（List） 列表是一种可变序列类型，所以通用的序列操作，如索引、分片、连接、乘等都适用于列表。除此之外，还有其他的一些改变列表的方法，如列表元素赋值、元素删除等等，下面概述一些常用操作。
字符串不能像列表一样被修改，有时候根据字符串创建列表会相当有用。如：
list(&#39;hello&#39;) # 返回[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]  元素赋值 即可以通过索引来单个元素赋值，也可以通过分片来批量赋值。具体看代码：
# 索引赋值修改元素 nums = [1, 2, 3] nums[1] = 5 print(nums) # 返回[1, 5, 3] names = [&#39;Tom&#39;, &#39;Lucy&#39;, &#39;Viky&#39;] names[0] = &#39;shawn&#39; print(names) # 返回[&#39;shawn&#39;, &#39;Lucy&#39;, &#39;Viky&#39;] # 分片赋值修改元素 strs = list(&#39;shawn.gu&#39;) # 返回[&#39;s&#39;, &#39;h&#39;, &#39;a&#39;, &#39;w&#39;, &#39;n&#39;, &#39;.&#39;, &#39;g&#39;, &#39;u&#39;] strs[-3:] = list(&#39;lalala&#39;) # strs返回[&#39;s&#39;, &#39;h&#39;, &#39;a&#39;, &#39;w&#39;, &#39;n&#39;, &#39;l&#39;, &#39;a&#39;, &#39;l&#39;, &#39;a&#39;, &#39;l&#39;, &#39;a&#39;] -- 插入了新元素 numbers = [1, 2] numbers[1:] = [4, 5, 6, 7, 8] print(numbers) # 返回[1, 4, 5, 6, 7, 8] -- 替换并且插入新元素  删除元素 可以通过del语句来删除列表元素，也可以使用分片实现删除效果，具体看代码：</description>
    </item>
    
    <item>
      <title>Python通用的序列（字符串、列表、索引等）操作</title>
      <link>https://shawngu.com/2018/03/python%E9%80%9A%E7%94%A8%E7%9A%84%E5%BA%8F%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E8%A1%A8%E7%B4%A2%E5%BC%95%E7%AD%89%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E9%80%9A%E7%94%A8%E7%9A%84%E5%BA%8F%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E8%A1%A8%E7%B4%A2%E5%BC%95%E7%AD%89%E6%93%8D%E4%BD%9C/</guid>
      <description>Python内建了多种序列类型，有字符串、列表、元组等等。其他可参考 https://docs.python.org/3/library/index.html
而序列类型有一些通用的操作，下面概述介绍一下
索引 序列中的所有元素都是有编号的，编号从0开始递增，而元素可以通过编号访问，这个编号就是索引。索引通过[n]来表示，n为编号。
 正数索引: 即从左向右正向索引。  name = &#39;shawn.gu&#39; name[1] # 返回 &#39;h&#39;   负数索引: 即从右向左反向索引。  name = &#39;shawn.gu&#39; name[-1] # 返回 &#39;u&#39;  分片 分片是一个非常有用的高级特性，合理利用，可以极大的提高程序编写和执行效率。分片通过冒号隔开索引来实现。完整的分片如:
[1:5:2]
第一数字1代表索引开始的编号，包含在索引结果内；第二个数字5代表索引结束的编号，不包含在索引结果内；第三个数字2代表的是步长，即每2个索引一个元素。
1、直接上代码：
url = &#39;https://docs.python.org/&#39; url[0:5] # 返回 &#39;https&#39; url[0:10:2] # 返回 &#39;hts/d&#39;  2、索引数字还可以是负数，表示从后向前索引。
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[-5:-1] # 返回[5, 6, 7, 8]  注：分片中最左边的索引元素不能比它右边的索引元素晚出现在序列中，否则结果为空序列。什么意思呢？看代码
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] numbers[-1:-3] # 返回 [] numbers[-2:-5] # 返回 [] numbers[-3:3] # 返回 []  3、当我们想从序列某个元素索引到最后一个元素时，可以省略右边索引编号。也同样适用于左边索引编号。</description>
    </item>
    
    <item>
      <title>Python字符串常用的方法</title>
      <link>https://shawngu.com/2018/03/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>Python为字符串的操作提供了相当丰富的方法，这里介绍一些常用的。
介绍字符方法前，简单介绍一个下字符串常量。
String constants Python字符串模块中，定义了一些字符串常量，可直接拿来用，很方便。
 string.ascii_letters：包含所有大写和小写字母的字符串。  import string print(string.ascii_letters) # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ   string.ascii_lowercase：包含所有小写字母的字符串。  print(string.ascii_lowercase) # abcdefghijklmnopqrstuvwxyz   string.ascii_uppercase：包含所有大写字母的字符串。  print(string.ascii_uppercase) # ABCDEFGHIJKLMNOPQRSTUVWXYZ   string.digits：包含0~9数字的字符串。  print(string.digits) # 0123456789   string.hexdigits：包含十六进制中所有字符的字符串。  print(string.hexdigits) # 0123456789abcdefABCDEF   string.octdigits ：包含八进制中所有数字的字符串。  print(string.octdigits) # 01234567   string.punctuation：包含所有的标点符号。  print(string.punctuation) # !&amp;quot;#$%&amp;amp;&#39;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~   string.printable：包含可打印字符的字符串。  print(string.printable) # 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&amp;quot;#$%&amp;amp;&#39;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~  字符串方法 find find方法可以在一个较长的字符串中寻找子串。如果存在，返回子串所在位置的最左端索引，如果不存在该子串，则返回-1。另外可指定搜索索引范围。
str = &#39;this is a test string for find method&#39; print(str.</description>
    </item>
    
    <item>
      <title>Python基本语法之普通数据类型</title>
      <link>https://shawngu.com/2018/03/python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%99%AE%E9%80%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 06 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2018/03/python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%99%AE%E9%80%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>不同的数据代表的不同的类型，那么在计算机语言中，使用不同的类型来定义不同的数据。
在解释类型之前，先说一下变量：
在python中，变量即某个值（或者引用）的名字，例如，num = 5，这时num这个名字就代表5。num就是一个变量，变量赋值（=）后，就可以在表达式中使用。
整型 即整数，如1、2、5……，这些都是整数，整数常用的操作有+、-、*、/、%等
a = 5 b = 20 print(a + b) # 25 print(a - b) # -15 print(a * b) # 100 print(a / b) # 0.25 print(a % b) # 5  浮点型 即浮点数、小数，如1.1、2.1、3.2、1.23e4等，浮点数和整数一样，有+、-、*、/、%等操作，结果还是浮点数
a = 1.2 b = 2.5 print(a + b) # 3.7 print(a - b) # -1.3 print(a * b) # 3.0 print(a / b) # 0.48 print(a % b) # 1.</description>
    </item>
    
    <item>
      <title>计算机中的按位运算、二进制和十进制相互转换、原码，反码和补码</title>
      <link>https://shawngu.com/2017/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</link>
      <pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</guid>
      <description>在计算机底层中，所有的运算都是采用二进制进行。所谓二进制，就是指逢二进一。二进制数由0、 1组成。
一个二进制数0或1在底层叫作1&amp;rdquo;位&amp;rdquo;。其中八个0或1组成的8位代表一个字节。
我们平时看到的字母、数字、汉字等在都是由字节组成，到计算机最底层就是由&amp;rdquo;位&amp;rdquo;来表示。
一般：
 一个整数占4个字节，一个字节由8组成，因此一个整数由32表示。 一个英文字母占1个字节，由8表示。 一个汉字占2个字节，由16位表示。  下面以整数为例：
按位运算 按位运算简单来说就是对位进行操作。
按位与（&amp;amp;） 按位与（&amp;amp;）运算：两个数相同位上的（二进制数）都为1，那么运算结果的相同位上的数也为1，其他都为0。
x = 00000000 00000000 00000000 00001010
y = 00000000 00000000 00000000 00110010
x &amp;amp; y = 00000000 00000000 00000000 00000010
按位或（|） 按位或(｜)运算：两个数相同位上的（二进制数）只要有一个是1，那么运算结果的相同位上的数就为1，否则为0。
x = 00000000 00000000 00000000 00001010
y = 00000000 00000000 00000000 00110010
x ｜ y = 00000000 00000000 00000000 00111010
按位异或（^） 按位异或（^）运算：两个数相同位的二进制数一个为1，一个为0，那么结果的相同位上的数为1，其他的都为0。
x = 00000000 00000000 00000000 00001010
y = 00000000 00000000 00000000 00110010</description>
    </item>
    
    <item>
      <title>Mongodb数据库和集合（表）的相关操作</title>
      <link>https://shawngu.com/2017/05/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9B%86%E5%90%88%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 16 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9B%86%E5%90%88%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>MongoDB是一个基于分布式文件存储的开源数据库系统，也是一款流行的NoSQL数据库。是一个介于关系数据库和非关系数据库之间的产品，旨在为web应用提供可扩展的高性能数据存储解决方案。
MongoDB将数据存储为一个文档，数据结构有键值对（k-v）组成。类似于JSON对象。字段值可以包含其他文档，数组及文档数组。
数据库的操作 MongoDB中默认的数据库为admin、local、config，如果没有创建新的数据库，集合会存放在local或者admin库中。
创建数据库 创建数据库使用use命令，表示如果没有给定库就创建，有则使用
&amp;gt; use test; switched to db test  查看数据库 1、查看所有数据库
&amp;gt; show dbs; admin 0.000GB config 0.000GB local 0.000GB  注：新创建的test数据库因为没有内容，所以不会显示。
2、查看当前数据库状态
&amp;gt; use test; &amp;gt; db.stats(); { &amp;quot;db&amp;quot; : &amp;quot;test&amp;quot;, &amp;quot;collections&amp;quot; : 0, &amp;quot;views&amp;quot; : 0, &amp;quot;objects&amp;quot; : 0, &amp;quot;avgObjSize&amp;quot; : 0, &amp;quot;dataSize&amp;quot; : 0, &amp;quot;storageSize&amp;quot; : 0, &amp;quot;numExtents&amp;quot; : 0, &amp;quot;indexes&amp;quot; : 0, &amp;quot;indexSize&amp;quot; : 0, &amp;quot;fileSize&amp;quot; : 0, &amp;quot;fsUsedSize&amp;quot; : 0, &amp;quot;fsTotalSize&amp;quot; : 0, &amp;quot;ok&amp;quot; : 1 }  删除数据库 删除数据库要先切换到要删除的库，然后使用db.</description>
    </item>
    
    <item>
      <title>Redis数据类型之集合（set）类型和有序集合（sorted set）类型的使用</title>
      <link>https://shawngu.com/2017/05/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88set%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88sorted-set%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 13 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88set%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88sorted-set%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>集合 Redis的set集合时string类型的无序集合。集合的每一元素时唯一的，不能出现重复的数据。
sadd SADD key member [member&amp;hellip;]
将一个或多个member元素加入到集合key中，已经存在集合的member元素将被忽略。
redis&amp;gt; SADD sports football basketball (integer) 2  smembers SMEMBERS key
返回集合key中的所有成员，不存在的key视为空集合。
redis&amp;gt; SMEMBERS sports 1) &amp;quot;basketball&amp;quot; 2) &amp;quot;football&amp;quot;  sismember SISMEMBER key member
判断member是否在集合中
redis&amp;gt; SISMEMBER sports football (integer) 1 redis&amp;gt; SISMEMBER sports pingpong (integer) 0  srem SREM key member [member&amp;hellip;]
移除集合key中一个或多个member元素，不存在的忽略
redis&amp;gt; SREM sports pingpong football (integer) 1 redis&amp;gt; SMEMBERS sports 1) &amp;quot;basketball&amp;quot;  scard SCARD key
返回集合key中的元素的数量</description>
    </item>
    
    <item>
      <title>Redis数据类型之列表（list）类型和哈希（hash）类型的使用</title>
      <link>https://shawngu.com/2017/05/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8list%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%93%88%E5%B8%8Chash%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8list%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%93%88%E5%B8%8Chash%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>列表 Redis列表是字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或尾部（右边）。一个列表最多可以包含 2^32-1 个元素。
lpush LPUSH key value [value&amp;hellip;]
将一个或多个值插入到列表的表头，即从左侧添加元素。如果key不存在，一个空列表会被创建并执行lpush操作。
redis&amp;gt; LPUSH langs java python php (integer) 3  rpush RPUSH key value [value&amp;hellip;]
将一个或多个值插入到列表的表尾，即从右侧插入元素。
redis&amp;gt; RPUSH langs shell (integer) 4  lrange LRANGE key start stop
返回key中指定区间内的元素，区间以偏移量start和stop指定。0代表第一个元素，-1代表最后一个元素。
redis&amp;gt; LRANGE langs 0 -1 1) &amp;quot;php&amp;quot; 2) &amp;quot;python&amp;quot; 3) &amp;quot;java&amp;quot; 4) &amp;quot;shell&amp;quot;  lpushx LPUSHX key value
将值value插入到列表key的表头，当且仅当key存在并且是一个列表。
redis&amp;gt; LPUSHX langs go redis&amp;gt; LRANGE langs 0 -1 1) &amp;quot;go&amp;quot; 2) &amp;quot;php&amp;quot; 3) &amp;quot;python&amp;quot; 4) &amp;quot;java&amp;quot; 5) &amp;quot;shell&amp;quot;  rpushx RPUSHX key value</description>
    </item>
    
    <item>
      <title>Redis数据类型之字符串（string）类型的使用</title>
      <link>https://shawngu.com/2017/05/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2string%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 10 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2string%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Redis（remote dictionary server)，是一个基于key-value的高速存储系统，也称为缓存系统。他遵循BSD协议、支持网络、可基于内存也可以数据持久化的日志性、k-v数据库。
Redis支持5中数据类型，有：字符串、列表、集合、有序集合、哈希。
键（key） keys KEYS pattern
用来查找复合给定模式pattern的key
 *：匹配所有的key，如keys *。 ?：匹配单个字符，如keys hell?，匹配hella、hello等。 []：匹配任意个给定的字符，可用“-”表示范围，如keys h[a-z]llo。  randomkey 从当前库中随机返回一个key。有key存在时返回任意一个，不存在时返回nil。如：
redis&amp;gt; MSET name &#39;shawn&#39; age 24 sex &#39;male&#39; redis&amp;gt; RANDOMKEY &amp;quot;age&amp;quot;  exists EXISTS key
检查给定key是否存在，如：
redis&amp;gt; EXISTS name (integer) 1 redis&amp;gt; EXISTS profile (integer) 0  ttl TTL key
返回给定key的剩余生存时间（time to live)，以秒为单位。
当key存在但没有设置剩余时间时，返回-1。
当key不存在时，返回-2
redis&amp;gt; TTL name (integer) -1 redis&amp;gt; TTL profile (integer) -2  pttl PTTL key
以毫秒为单位返回给定key的剩余生存时间，和ttl类型。</description>
    </item>
    
    <item>
      <title>MySQL常用优化概述</title>
      <link>https://shawngu.com/2017/05/mysql%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Sun, 07 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/mysql%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/</guid>
      <description>MySQL优化一般从四个层面着手。
设计 设计方面包括字段类型的选择、存储引擎的选择、特定范式
字段选择 在满足需求的情况下：
 选择短数据类型：占用存储空间小 选择定长数据类型：占用固定的存储空间，运行速度比较快 使用整数替代字符串：整数的计算效率高，有时也会节省存储空间；如：性别sex使用tinyint类型要比enum类型或字符串效率高 限定表的字段数量：一个表字段数量尽量不要超过30个 字段设置NOT NULL：字段为null时，存储和计算都需要额外的特殊处理；如 null参与运算结果都为null，存储时也会消耗一定的空间。所以设置为not null，配合 default 使用注释：保证完整性 使用一些通过字段：如id、create_at、update_at等  存储引擎 MySQL中常用的存储引擎有：Myisam、InnoDB。推荐使用InnoDB。
1、Myisam和InnoDB的存储方式：
 Myisam：  Myisam将数据和索引分别存储在不同的文件中，数据文件格式为xxx.MYD，索引文件格式为xxx.MYI，结构文件为xxx.frm。
记录的存储顺序就是插入记录时的顺序。
 InnoDB：  InnoDB将数据和索引存储在一个文件中，格式为xxx.ibd（称为表空间文件）、以及一个结构结构文件xxx.frm。之外还包含公共的innodb文件。
记录的存储顺序是主键值顺序。
MySQL新版中每个表有一个表空间文件，如果不是，可通过指令来设置
-- 查看是否开启 SHOW VARIABLES LIKE &amp;quot;innodb_file_per_table&amp;quot;; /* +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | innodb_file_per_table | OFF | +-----------------------+-------+ */ -- 开启 SET GLOBAL innodb_file_per_table = ON;  注：Myisam的文件可以通过拷贝的方式备份，而InnoDB的文件只能通过mysqldump导出部分。
2、事务和并发支持
Myisam不支持事务，InnoDB支持事务，是事务安全型存储引擎。
InnoDB的并发性优于Myisam，因为InnoDB支持ROW-LEVEL（行级）锁定，一次仅仅锁定操作的行，InnoDB支持MVCC（多版本控制），几乎可以做到无阻塞读操作。而Myisam仅仅支持TABLE-LEVEL（表级）锁定，只能锁定全表。
范式 范式，即规范。数据库设计时遵循的规则。数据库设计中，目前依据级别定义有：1NF、2NF、3NF、4NF、5NF、6NF这6个范式。后面的每一个范式都必须满足前面的范式。
而我们设计数据库时，一般满足前3个范式。
1、第一范式（1NF）&amp;ndash; 原子性：</description>
    </item>
    
    <item>
      <title>MySQL用户管理</title>
      <link>https://shawngu.com/2017/05/mysql%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 05 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/mysql%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</guid>
      <description>在MySQL数据库系统中，用户存储在mysql库的user表中，即mysql.user。
SHOW CREATE TABLE mysql.user \G -- 结构 /* Create Table: CREATE TABLE `user` ( `Host` char(60) COLLATE utf8_bin NOT NULL DEFAULT &#39;&#39;, `User` char(16) COLLATE utf8_bin NOT NULL DEFAULT &#39;&#39;, `Password` char(41) CHARACTER SET latin1 COLLATE latin1_bin NOT NULL DEFAULT &#39;&#39;, `Select_priv` enum(&#39;N&#39;,&#39;Y&#39;) CHARACTER SET utf8 NOT NULL DEFAULT &#39;N&#39;, 。。。 PRIMARY KEY (`Host`,`User`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;Users and global privileges&#39;; */  其中：
 Host：表示用户登录的ip User：用户名 Password：用密码，通过password加密 xxx_priv：权限，值为Y代表用户有这个权限，N代表没有这个权限  创建用户 格式： &amp;gt; CREATE USER &amp;lsquo;username&amp;rsquo;@&amp;lsquo;ip&amp;rsquo; IDENTIFIED BY &amp;lsquo;password&amp;rsquo;</description>
    </item>
    
    <item>
      <title>MySQL事务和存储引擎</title>
      <link>https://shawngu.com/2017/05/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Wed, 03 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>事务 事务是用来保证数据的一致性的，它由一组相关的DML语句组成，这组DML语句要么全部执行成功，要么全部失败。如：银行转账业务，即为典型的事务应用场景。
事务的几个重要操作：
 start transaction: 开始一个事务 savepoint：设置一个保存点 rollback to：回退掉某个保存点 commit：事务提交，执行指令  注：如果没有设置保存点，事务开始时会自动创建一个匿名保存点；当有多个保存点时，事务回退需要依次回退，回退到前面的保存点，后面的即被销毁。要使用事务，存储引擎必须支持事务，MySQL中一般选择INNODB。
创建一张测试表
CREATE TABLE `users` ( id int unsigned primary key auto_increment comment &#39;自增编号&#39;, name varchar(32) not null default &#39;&#39; comment &#39;姓名&#39;, age smallint unsigned not null default 0 comment &#39;年龄&#39; )CHARSET=utf8 COLLATE=utf8_general_ci;  事务操作，测试回退
-- 开始事务 START TRANSACTION; -- 设置不自动提交 SET AUTOCOMMIT = false; -- 设置保存点 SAVEPOINT st; -- 一组dml语句 INSERT INTO `users` (name, age) VALUES (&#39;tom&#39;, 25), (&#39;jack&#39;, 24), (&#39;rose&#39;, 21), (&#39;lucy&#39;, 26); DELETE FROM `users` WHERE id = 2; 这个时候指令还没有真正执行，我们可以回退到保存点 ROLLBACK TO st; SELECT * FROM `users`; /* Empty set (0.</description>
    </item>
    
    <item>
      <title>MySQL约束和索引</title>
      <link>https://shawngu.com/2017/05/mysql%E7%BA%A6%E6%9D%9F%E5%92%8C%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/05/mysql%E7%BA%A6%E6%9D%9F%E5%92%8C%E7%B4%A2%E5%BC%95/</guid>
      <description>约束 在设计表时，我们往往需要字段满足某个条件，如该字段值不能重复、不能为空等，这些都是约束。
分类：
 主键约束（primary key） 唯一约束（unique） 不为空约束（not null） 外键约束（foreign key），一般不设置，表与表之间的主从关系从开发人员维护  主键约束 关键字：PRIMARY KEY
使用：
-- 建表时设置主键约束 CREATE TABLE `users` ( id int unsigned primary key )CHARSET=utf8 COLLATE=utf8_general_ci; -- 或在最后语句中设置 CREATE TABLE `users` ( id int unsigned， primary key(id) )CHARSET=utf8 COLLATE=utf8_general_ci;  注：当字段设置为主键后，主键的字段默认不能null，且值不能重复。一张表只能有一个主键，但可以设置复合主键。
复合主键：
-- id和name两个字段组成一个复合主键 CREATE TABLE `users` ( id int unsigned， name varchar(32), primary key(id, name) )CHARSET=utf8 COLLATE=utf8_general_ci;  唯一约束 关键字：UNIQUE
使用：
CREATE TABLE `users` ( id int unsigned primary key, name varchar(32) unique )CHARSET=utf8 COLLATE=utf8_general_ci;  注：字段设置唯一约束后，该字段值不能重复。如何未设置不为空约束，该字段可为null。一张表可以设置多个唯一约束。</description>
    </item>
    
    <item>
      <title>MySQL查询中使用流程控制函数及多表查询</title>
      <link>https://shawngu.com/2017/04/mysql%E6%9F%A5%E8%AF%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0%E5%8F%8A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sun, 30 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E6%9F%A5%E8%AF%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0%E5%8F%8A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</guid>
      <description>流程控制 在MySQL查询中，可以通过使用流程控制函数进行过滤或做一些额外的操作
IF IF(expr1, expr2, expr3)，如果expr1为True，则返回expr2，否则返回expr3。如：
SELECT name, IF(salary is null, 0.0, salary) FROM emps;  IFNULL IFNULL(expr1, expr2)，如果expr1为null值，则返回expr2。如：
SELECT sum(IFNULL(chiness, 0) + IFNULL(math, 0)) AS total FROM students;  CASE&amp;hellip;WHEN&amp;hellip;THEN&amp;hellip;ELSE&amp;hellip;END CASE&amp;hellip;WHEN&amp;hellip;，条件分支
SELECT name, ( CASE WHEN salary &amp;lt;= 5000 THEN salary * 1.5 WHEN salary &amp;lt;= 8000 THEN salary * 1.2 WHEN salary &amp;gt;8000 AND salary &amp;lt;= 10000 THEN salary * 1.1 ELSE salary END ) AS updSalary FROM emps;  其他的一些细节描述可参考：https://dev.</description>
    </item>
    
    <item>
      <title>MySQL表数据的查询（select）</title>
      <link>https://shawngu.com/2017/04/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9F%A5%E8%AF%A2select/</link>
      <pubDate>Sat, 29 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9F%A5%E8%AF%A2select/</guid>
      <description>查询select是数据库中最重要的部分。也是开发中最常见的功能。
简单查询 即单表查询
基本语法  SELECT [DISTINCT] * ¦ {col1, col2, col3, &amp;hellip;} FROM table_name [WHERE where_expr] [GROUP BY {col_name ¦ expr} [ASC ¦ DESC]] [HAVING where_condition] [ORDER BY&amp;gt; {col_name ¦ expr} [ASC ¦ DESC]] [LIMIT row_count]
 其中：
 红色字为关键字，一般大写 []的内容可有可无，基本都为过滤条件 distinct表示过滤掉重复的记录 *表示查询所有字段，一般不用，效率太低  在查询之前先创建一张表，并插入一些数据
-- 创建一张users表，用来查询 CREATE TABLE `users` ( id int(8) unsigned not null default 0 comment &#39;编号&#39;, name varchar(32) not null default &#39;&#39; comment &#39;姓名&#39;, age smallint(4) unsigned not null default 0 comment &#39;年龄&#39;, address varchar(64) not null default &#39;&#39; comment &#39;地址&#39;, profile text comment &#39;个人介绍&#39; )CHARSET=utf8 COLLATE utf8_general_ci; -- 显示表创建时的结构 SHOW CREATE TABLE `users` \G /* *************************** 1.</description>
    </item>
    
    <item>
      <title>MySQL表数据的插入、修改、删除操作（crud之cud操作）</title>
      <link>https://shawngu.com/2017/04/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9Ccrud%E4%B9%8Bcud%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9Ccrud%E4%B9%8Bcud%E6%93%8D%E4%BD%9C/</guid>
      <description>所谓的crud是指：
c(create): 添加、r(read): 读取、u(update): 修改、d(delete): 删除。
其中cud在MySQL中对应(insert、update、delete)，即DML。
insert 插入数据操作。
基本语法  INSERT INTO  table_name [(col_name, col_name, &amp;hellip;)] VALUES (val, val, &amp;hellip;), &amp;hellip;
 其中：
 红色的为关键字 col_name要和val一一对应，省略col_name时，表示所有字段都插入数据。 insert也可以一次性插入多条记录  -- 插入一条记录 INSERT INTO `users` (id, name, profile) VALUES (1, &#39;peter&#39;, &#39;this is peter&#39;); -- 插入多条记录 INSERT INTO `users` (id, name, profile) VALUES (2, &#39;lucy&#39;, &#39;this is lucy&#39;), (3, &#39;jack&#39;, &#39;this is jack&#39;), (4, &#39;tom&#39;, &#39;this is tom&#39;); -- 查询结果 SELECT * FROM `users`; /* +----+-------+---------------+ | id | name | profile | +----+-------+---------------+ | 1 | peter | this is peter | | 2 | lucy | this is lucy | | 3 | jack | this is jack | | 4 | tom | this is tom | +----+-------+---------------+ 4 rows in set (0.</description>
    </item>
    
    <item>
      <title>MySQL数据表的操作（增加、修改、删除字段）</title>
      <link>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%8A%A0%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5/</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%8A%A0%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5/</guid>
      <description>在项目开发过程中，我们的需求有时会发生变化，如修改表名、新增表字段、删除表字段、修改表字段等。对表的字段或相关结构的操作可通过ALTER语句来实现。
基本语法：
1、新增字段
 ALTER TABLE table_name ADD [COLUMN] col_name column_definition [FIRST ¦ AFTER col_name]
 其中：
 红色字为关键字，固定。 []里的表示可有可无 table_name表示表名，col_name表示列（字段）名，column_definitin字段描述 first表示让该字段位于第一个，这个时候就不能有后面的col_name，after表示在字段col_name之后。  CREATE TABLE `users` ( id int unsigned not null default 0 comment &#39;编号&#39;, name varchar(32) not null default &#39;&#39; comment &#39;名字&#39; )CHARSET=utf8 COLLATE utf8_general_ci; -- 给`users`表name字段后面增加profile字段 ALTER TABLE `users` ADD profile varchar(256) not null default &#39;&#39; comment &#39;个人描述&#39; AFTER name; DESC `users`; -- 表信息 /* +---------+------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+------------------+------+-----+---------+-------+ | id | int(10) unsigned | NO | | 0 | | | name | varchar(32) | NO | | | | | profile | varchar(256) | NO | | | | +---------+------------------+------+-----+---------+-------+ 3 rows in set (0.</description>
    </item>
    
    <item>
      <title>MySQL数据类型之日期时间类型</title>
      <link>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 26 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B/</guid>
      <description>日期时间类型也是常用的数据类型，而用的最多的有：date、datetime、timestamp。
date date类型用来存储日期，没有时间，存储的格式为&amp;lsquo;YYYY-MM-DD&amp;rsquo;，而支持的日期范围为&amp;lsquo;1000-01-01&amp;rsquo; ~ &amp;lsquo;9999-12-31&amp;rsquo;。
CREATE TABLE `users` ( id int unsigned not null default 0, name varchar(32) not null default &#39;&#39;, birthday date not null default &#39;1900-01-01&#39; )CHARSET=utf8; INSERT INTO `users` (id, name, birthday) VALUES (1, &#39;tom&#39;, &#39;1993-02-10&#39;); SELECT * FROM `users`; -- 返回信息 /* +----+------+------------+ | id | name | birthday | +----+------+------------+ | 1 | tom | 1993-02-10 | +----+------+------------+ */  datetime datetime类型存储日期和时间，存储格式为&amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo;，支持的范围为&amp;lsquo;1000-01-01 00:00:00&amp;rsquo; ~ &amp;lsquo;9999-12-31 23:59:59&amp;rsquo;。</description>
    </item>
    
    <item>
      <title>MySQL数据类型之枚举（enum）和集合（set）类型</title>
      <link>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9E%9A%E4%B8%BEenum%E5%92%8C%E9%9B%86%E5%90%88set%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9E%9A%E4%B8%BEenum%E5%92%8C%E9%9B%86%E5%90%88set%E7%B1%BB%E5%9E%8B/</guid>
      <description>枚举（enum） 枚举类型就是一个字符串对象，在创建表时，枚举的所有值都被定义好放到一个列表中，该类型字段只要从列表中取得枚举的值即可，如：
CREATE TABLE `shirts` ( name VARCHAR(40), size ENUM(&#39;x-small&#39;, &#39;small&#39;, &#39;medium&#39;, &#39;large&#39;, &#39;x-large&#39;) ); INSERT INTO `shirts` (name, size) VALUES (&#39;dress shirt&#39;,&#39;large&#39;), (&#39;t-shirt&#39;,&#39;medium&#39;), (&#39;polo shirt&#39;,&#39;small&#39;); SELECT name, size FROM `shirts` WHERE size = &#39;medium&#39;; -- 返回信息 /* +---------+--------+ | name | size | +---------+--------+ | t-shirt | medium | +---------+--------+ */  注：枚举类型，可看成是“单选”类型，最直观的就是对应网页表单中的“单选项”的值。MySQL出于对象效率的考虑，枚举值列表中的每一项在MySQL中都是存储其对应的索引数字，如第一项对应于1，第二项对应于2，依次类推，最多存储的是65535个。如果枚举值为null，则对应索引为null，值为空字符串时，对应索引为0。
集合（set） 集合类型也是一个字符串类型，但是它可以有0个或者多个值，其值也是从创建表时就定义好的集合列表中取得。如：
CREATE TABLE `profiles` ( name varchar(32), hobbies set(&#39;football&#39;, &#39;basketball&#39;, &#39;pingpong&#39;, &#39;computer&#39;, &#39;swimming&#39;) ); INSERT INTO `profiles` (name, hobbies) VALUES (&#39;tom&#39;, &#39;computer,swimming&#39;); INSERT INTO `profiles` (name, hobbies) VALUES (&#39;jack&#39;, &#39;&#39;); SELECT * FROM `profiles`; -- 显示信息 /* +------+-------------------+ | name | hobbies | +------+-------------------+ | tom | computer,swimming | | jack | | +------+-------------------+ */  而如果使用MySQL函数来查询集合值，应当使用find_in_set(value,fields)，其中fields是一个字符串，用逗号隔开，而返回值是其在集合中的索引，即第几个。如：</description>
    </item>
    
    <item>
      <title>MySQL数据类型之字符串类型</title>
      <link>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 24 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/</guid>
      <description>在MySQL中，字符串类型是常见的数据类型，而字符串中用的最多的要数：char(size)、varchar(size)、text这三种。如：
CREATE TABLE `user_info` ( id int unsigned not null default 0, name varchar(32) not not null default &#39;&#39;, sex char(2) not null default &#39;男&#39;, profile text )  细节说明：
1、char(size)和varchar(size)中size范围：
 char(size)中，size的范围为 1~255 varchar(size)中，size范围是变化的，主要和表所选的编码有关：
 如表的字符编码为utf8时，size的最大值则为 (65535-3)/3 = 21844。解释：在varchar中，有2个字节用于记录varchar保存的内容长度，1个字节用来记录该varchar是否为null，而utf8编码采用三个字节保存一个字符，所以除以3。 当表的字符编码为gbk时，size的最大值为 (65535-3)/3 = 32766。解释：gbk使用两个字节保存一个字符，所以除以2。 而当表的字符编码为latin1时，size的最大值则为 (65535-3)/1 = 65532。解释：因为latin1使用一个字节保存一个字符，所以除以1。  注：char(size)和varchar(size)中，size指的是存放的字符数，而不是字节。
  2、char和varchar的不同之处：
 char(size)表示的是定长的字符串，如char(4)，这个时候即使我们插入&amp;rsquo;ab&amp;rsquo;(不足4个)，它也占4个字符的长度。 varchar(size)表示的是变长的字符串，如varchar(1000)，当我们插入&amp;rsquo;abcd&amp;rsquo;时，实际占用的空间为四个字符的长度+1个字节（因为varchar除了保存值时，还要使用一个字节来记录长度），举个栗子：假设我们的表字符编码为utf8，存储了&amp;rsquo;abcd&amp;rsquo;，这个时候所占空间为 s = 4 * 3 + 1 = 13 个字节（utf8中一个字符使用3个字节表示）。  3、char类型在存储内容时，如果内容的末尾是空格，则该空格就会丢失掉，而varchar会保留末尾的空格。如：
CREATE TABLE `test` ( char_content char(4), varchar_content varchar(256) )charset = utf8; INSERT INTO `test` VALUES (&#39;ab &#39;, &#39;ab &#39;); SELECT length(char_content), length(varchar_content) from `test`; -- 显示 /* +----------------------+-------------------------+ | length(char_content) | length(varchar_content) | +----------------------+-------------------------+ | 2 | 3 | +----------------------+-------------------------+ */  4、当使用varchar时，一个表中的所有字段内容加起来不能超过65535个字节。如：</description>
    </item>
    
    <item>
      <title>MySQL数据类型之数值类型</title>
      <link>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 23 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</guid>
      <description>在介绍数据类型前，先简单说一下MySQL表的创建。
基本语法：
 CREATE TABLE table_name ( &amp;ensp;&amp;ensp;field1 datatype, &amp;ensp;&amp;ensp;field2 datatype, &amp;ensp;&amp;ensp;field3 datatype )CHARACTER SET 字符集 COLLATE 校验规则 ENGINE 存储引擎
 其中：
 红色的字为建表关键字，一般大写 field是字段名，如name、age等，一般采用下划线法。 datatype是字段类型，下面介绍 最后是一些额外指定项，如指定字符集、校验规则和存储引擎等  代码：
CREATE TABLE `user` ( id int not null default 0 comment &#39;编号&#39;, name varchar(32) not null default &#39;&#39; comment &#39;用户名&#39; )CHARSET=utf8 COLLATE utf8_general_ci ENGINE = myisam;  说明：
 表名一般使用反引号``括起来，防止和关键字冲突 not null表示该字段的值不能为空 default指定默认值，当不给值时就使用默认值 comment表示对该字段的注释  数据类型 我们在创建表时，字段要设置数据类型，而根据具体的业务选择正确合适的数据类型很重要。
数值型 1、整数
在MySQL中整数类型有五种，见下表：</description>
    </item>
    
    <item>
      <title>MySQL基础之建库相关基本操作语法和一些细节</title>
      <link>https://shawngu.com/2017/04/mysql%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BB%BA%E5%BA%93%E7%9B%B8%E5%85%B3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%AD%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</link>
      <pubDate>Fri, 21 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://shawngu.com/2017/04/mysql%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BB%BA%E5%BA%93%E7%9B%B8%E5%85%B3%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%AD%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</guid>
      <description>MySQL是目前使用的最广泛的关系型数据库管理系统之一，因其开源、免费、轻量、性能优越等优势深受企业的偏爱。
在MySQL中，通过SQL语言，即结构化查询语言进行数据库管理。
SQL语句分类：
 DDL（数据定义语言）：如常见的 create[创建]、drop[删除]、alter[修改] DML（数据操纵语言）：如常见的 insert[添加]、update[修改]、delete[删除] DQL（数据查询语言）：常见就是 select[查询] DCL（数据控制语言）：常见的有 grant[授权]、revoke[回收]、savepoint[事务保存点]、commit[事务提交]、rollback[事务回滚]  数据库创建 使用数据库管理系统，那么首先得有数据库
基本语法  CREATE DATABASE [IF NOT EXISTS] db_name [create_specification,&amp;hellip;]
 其中：
 红色的create database 是建库关键字，关键字一般用大写字母。 中括号[]里内容是可选项，可有可无。 if not exists也是关键字，是指建库时做个判断，防止数据库已存在的问题。 db_name 是将要创建的数据库名，如：user等。 create_specification 是一些额外指定项，如指定字符编码：[default] character set utf8；指定字符校验规则：[default] collate utf8_general_ci(不区分字符大小写)  代码：
CREATE DATABASE `shop`;  说明：建库时，没有指定字符集和检验规则的时候，默认是utf8和utf8_general_ci，而库名上加反引号，用来防止数据库名和关键字一样而引起问题。
创建指定字符集和校验规则的数据库：
-- way1: CREATE DATABASE `shop` CHARACTER SET utf8 COLLATE utf8_general_ci; -- way2: CREATE DATABASE `shop` DEFAULT CHARACTER utf8 COLLATE utf8_general_ci; -- way3: CREATE DATABASE `shop` CHARSET = utf8 COLLATE utf8_general_ci;  注：不同的字符集对应的编码不一样，存储的数据也就不一样，如utf8编码可以存储中文汉字，而latin1编码只能存放字母。另外，检验规则分为区分大小写和不区分大小写两种形式，带_ci表示不区分大小写，而不带的则为区分大小写，如utf8_general_ci不区分大小写，utf8_general区分大小写。</description>
    </item>
    
  </channel>
</rss>